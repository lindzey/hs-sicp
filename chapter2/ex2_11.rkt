#lang racket

(require (except-in "./interval_arithmetic.rkt" mul-interval))


(define (neg-interval x)
  (and (< (lower-bound x) 0)
       (< (upper-bound x) 0)))
(define (pos-interval x)
  (and (ge (lower-bound x) 0)
       (ge (upper-bound x) 0)))
(define (zero-interval x)
  (and (< (lower-bound x) 0)
       (ge (upper-bound x) 0)))

;; testing these
(define x (make-interval -4 -2))
(define y (make-interval -2 2))
(define z (make-interval 2 4))
(display "testing negative interval")
(newline)
(neg-interval x)
(zero-interval x)
(pos-interval x)
(display "testing a zero-spanning interval")
(newline)
(neg-interval y)
(zero-interval y)
(pos-interval y)
(display "testing positive interval")
(newline)
(neg-interval z)
(zero-interval z)
(pos-interval z)

(define (mul-interval a b)
  (cond ((and (neg-interval a) (neg-interval b))
         (make-interval (* (upper-bound a) (upper-bound b))
                        (* (lower-bound a) (lower-bound b))))
        ((and (neg-interval a) (zero-interval b))
         (make-interval (* (lower-bound a) (upper-bound b))
                        (* (lower-bound a) (lower-bound b))))
        ((and (neg-interval a) (pos-interval b))
         (make-interval (* (lower-bound a) (upper-bound b))
                        (* (upper-bound a) (lower-bound b))))
        ((and (zero-interval a) (neg-interval b))
         (make-interval (* (upper-bound a) (lower-bound b))
                        (* (lower-bound a) (lower-bound b))))
        ((and (zero-interval a) (zero-interval b))
         (let ((p1 (* (lower-bound a) (lower-bound b)))
               (p2 (* (lower-bound a) (upper-bound b)))
               (p3 (* (upper-bound a) (lower-bound b)))
               (p4 (* (upper-bound a) (upper-bound b))))
           (make-interval (min p2 p3)
                          (max p1 p4))))
        ((and (zero-interval a) (pos-interval b))
         (make-interval (* (lower-bound a) (upper-bound b))
                        (* (upper-bound a) (upper-bound b))))
        ((and (pos-interval a) (neg-interval b))
         (make-interval (* (upper-bound a) (lower-bound b))
                        (* (lower-bound a) (upper-bound b))))
        ((and (pos-interval a) (zero-interval b))
         (make-interval (* (upper-bound a) (lower-bound b))
                        (* (upper-bound a) (upper-bound b))))
        ((and (pos-interval a) (pos-interval b))
         (make-interval (* (lower-bound a) (lower-bound b))
                        (* (upper-bound a) (upper-bound b))))
        )
  )
             
;; testing that mul-interval2 has same results as mul-interval
;; old version from book for comparison purposes
(define (mul-interval-old x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (eq-interval? a b)
  (and (= (lower-bound a) (lower-bound b))
       (= (upper-bound a) (upper-bound b))))

(display "testing new interval multiplication")
(newline)
(eq-interval? (mul-interval x x) (mul-interval-old x x))
(eq-interval? (mul-interval x y) (mul-interval-old x y))
(eq-interval? (mul-interval x z) (mul-interval-old x z))

(eq-interval? (mul-interval y x) (mul-interval-old y x))
(eq-interval? (mul-interval y y) (mul-interval-old y y))
(eq-interval? (mul-interval y z) (mul-interval-old y z))

(eq-interval? (mul-interval z x) (mul-interval-old z x))
(eq-interval? (mul-interval z y) (mul-interval-old z y))
(eq-interval? (mul-interval z z) (mul-interval-old z z))
